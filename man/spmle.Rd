% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation_functions.R
\name{spmle}
\alias{spmle}
\title{Semiparametric Maximum Pseudolieklihood Estimator for Case-Control Studies Under G-E Independence.}
\usage{
spmle(D, G, E, pi1, data, control = list(), swap = FALSE, startvals)
}
\arguments{
\item{D}{a binary vector of disease status (1=case, 0=control).}

\item{G}{a vector or matrix (if multivariate) containing genetic data. Can be continuous, discrete, or a combination.}

\item{E}{a vector or matrix (if multivariate) containing environmental data. Can be continuous, discrete, or a combination.}

\item{pi1}{the population disease rate, a scalar in [0, 1) or the string "rare".
Using \code{pi1=0} is the rare disease approximation.}

\item{data}{an optional list or environment containing the variables in the model.
If not found in \code{data}, the variables are taken from the environment
from which \code{spmle} is called.}

\item{control}{a list of control parameters that allow the user to control the optimization algorithm.  See 'Details'.}

\item{swap}{a logical scalar rarely of interest to the end user.  Dependence on the distributions of G and E
are removed using different methods; this switch swaps them to produce a symmetric estimator with identical
properties to the SPMLE.  Default \code{FALSE}.}

\item{startvals}{an optional numeric vector of coefficient starting values for optimization.  Usually left blank,
in which case logistic regression estimates are used as starting values.}
}
\value{
an object of class \code{"spmle"}.  The function \code{summary} (i.e., \code{summary.spmle})
  can be used to obtain or print a summary of the results.

  The function \code{anova} (i.e., \code{anova.spmle}) will conduct likelihood-ratio
  tests comparing one \code{spmle} object to another.  These are valid tests
  because the loglikelihood reported by \code{logLik.spmle} is accurate up to
  an additive constant.  However \code{anova} should not be used
  to compare an \code{spmle} object to a model fit by a different method.

  \code{\link{predict.spmle}}, the \code{predict} method for S3 class \code{"spmle"},
  can predict the expected response (on logistic or probability scales), compute
  confidence intervals for the expected response, and provide standard errors.

  The generic accessor functions \code{coefficients}, \code{fitted.values}
  and \code{residuals} can be used to extract various useful features of the
  value returned by \code{spmle}.

  An object of class \code{"spmle"} is a list containing at least the following components:
\describe{
  \item{\code{coefficients}}{a named vector of coefficients}
  \item{\code{pi1}}{the value of pi1 used during the analysis}
  \item{\code{SE}}{standard error estimate of coefficients}
  \item{\code{cov}}{estimated covariance matrix of coefficients}
  \item{\code{glm_fit}}{a logistic regression model fit using the same model as \code{spmle}}
  \item{\code{call}}{the matched call}
  \item{\code{formula}}{the formula used}
  \item{\code{data}}{the \code{data argument}}
  \item{\code{model}}{the model frame}
  \item{\code{terms}}{the \code{terms} object used}
  \item{\code{linear.predictors}}{the linear fit on the logistic link scale}
  \item{\code{fitted.values}}{the fitted values on the probability scale}
  \item{\code{residuals}}{the Pearson residuals}
  \item{\code{null.deviance}}{the deviance for the null model.  Deviance = \code{-2*logLik}.}
  \item{\code{df.residual}}{the residual degrees of freedom}
  \item{\code{df.null}}{the residual degrees of freedom for the null model}
  \item{\code{rank}}{the numeric rank of the fitted linear model
    (i.e. the number of parameters estimated)}
  \item{\code{nobs}}{number of observations}
  \item{\code{ncase}}{number of cases}
  \item{\code{ncontrol}}{number of controls}
}

\code{spmle} objects created by \code{spmle()} additionally have components \code{logLik}
(log pseudolikelihood), \code{deviance} (-2 * log pseudolikelihood), \code{aic}, \code{bic},
\code{ucminf} (optimization output), and matrices \code{H_inv}, \code{Sigma}, \code{zeta0},
and \code{zeta1}, which are used in calculating the asymptotic estimate of standard error.
}
\description{
\code{spmle} maximizes the retrospective pseudolikelihood of case-control data under the assumption
of G-E independence in the underlying population.
The marginal distributions of G and E are treated nonparametrically.
}
\details{
This function applies the method of Stalder et. al. (2017) to maximize the
retrospective pseudolikelihood of case-control data under the assumption of G-E independence.
It currently supports the model with G and E main effects and a multiplicative G*E interaction.

The \code{control} argument is a list that controls the behavior of the optimization algorithm
\code{\link[ucminf]{ucminf}} from the \pkg{ucminf} package.  When \code{ucminf} works,
it works brilliantly (typically more than twice as fast as the next-fastest algorithm).
But it has a nasty habit of declaring convergence before actually converging.
To address this, \code{spmle} checks the maximum gradient at "convergence", and can rerun the optimization
using different starting values.  The \code{control} argument can supply any of the following components:
\describe{
  \item{\code{max_grad_tol}}{maximum allowable gradient at convergence.  \code{spmle} does not
    consider the optimization to have converged if the maximum gradient \code{> max_grad_tol}
    when \code{ucminf} stops. Default \code{max_grad_tol} \code{= 0.001}.}
  \item{\code{num_retries}}{number of times to retry optimization.  An error is produced if
    the optimization has not converged after \code{num_retries}.  Different starting values
    are used for each retry.  Default \code{num_retries = 2}.}
  \item{\code{use_hess}}{a logical value instructing \code{spmle} to use the analytic hessian
    to precondition the optimization.  This brings significant speed benefits, and is one reason
    \code{ucminf} is so fast.  For unknown reasons, preconditioning causes computers with
    certain Intel CPUs to prematurely terminate iterating.  By default, \code{use_hess = TRUE},
    but if you notice that \code{ucminf} never converges during the first attempt, try setting \code{use_hess = FALSE}.}
  \item{\code{trace}}{a scalar or logical value that is used by both \code{spmle} and \code{ucminf}
    to control the printing of detailed tracing information.
    If TRUE or > 0, details of each \code{ucminf} iteration are printed.
    If FALSE or 0, \code{ucminf} iteration details are suppressed but \code{spmle} still
    prints optimization retries.  If \code{trace < 0} nothing is printed.  Default \code{trace = 0}.}
  \item{additional control parameters}{not used by \code{spmle}, but are passed to \code{\link[ucminf]{ucminf}}.
    Note that the \code{ucminf} algorithm has four stopping criteria, and \code{ucminf} will
    declare convergence if any one of them has been met.  The \code{ucminf} control parameter
    "\code{grtol}" controls \code{ucminf}'s gradient stopping criterion, which defaults to
    \code{1e-6}.  \code{grtol} should not be set larger than the \code{spmle} control parameter \code{max_grad_tol}.}
}
}
\section{References}{

Stalder, O., Asher, A., Liang, L., Carroll, R. J., Ma, Y., and Chatterjee, N. (2017).
\emph{Semi-parametric analysis of complex polygenic gene-environment interactions in case-control studies.}
Biometrika, 104, 801â€“812.
}

\examples{
# Simulation from Table 1 in Stalder et. al. (2017)
set.seed(2018)
dat = simulateCC(ncase=500, ncontrol=500, beta0=-4.165,
                 betaG_SNP=c(log(1.2), log(1.2), 0, log(1.2), 0),
                 betaE_bin=log(1.5),
                 betaGE_SNP_bin=c(log(1.3), 0, 0, log(1.3), 0),
                 MAF=c(0.1, 0.3, 0.3, 0.3, 0.1),
                 SNP_cor=0.7, E_bin_freq=0.5)

# SPMLE with known population disease rate of 0.03
spmle(D=D, G=G, E=E, pi1=0.03, data=dat)

# Simulation with a single SNP and a single binary environmental variable.
# True population disease rate in this simulation is 0.03.
# This simulation scenario was used in the Supplementary Material of Stalder et. al. (2017)
# to compare performance against the less flexible method of Chatterjee and Carroll (2005),
# which is available as the function as snp.logistic in the Bioconductor package CGEN.
dat2 = simulateCC(ncase=100, ncontrol=100, beta0=-3.77,
                  betaG_SNP=log(1.2), betaE_bin=log(1.5),
                  betaGE_SNP_bin=log(1.3), MAF=0.1,
                  E_bin_freq=0.5)

# SPMLE using the rare disease assumption, optimization tracing,
# and no hessian preconditioning.
spmle(D=D, G=G, E=E, pi1=0, data=dat2, control=list(trace=0, use_hess=FALSE))
}
\seealso{
\code{\link{spmleCombo}} for a slower but more precise estimator, \code{\link{simulateCC}} to simulate data
}
